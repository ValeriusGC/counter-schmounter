# Critical Path: Local-first Baseline — Action Plan

**Timestamp (Europe/Amsterdam): 2025-12-30 00:31**

Документ предназначен как **прямая программа действий** для реализации baseline (Auth optional + Local-first + Operation-based Counter). Без теории, без альтернатив — только последовательные шаги.

---

## Шаг 1 — Убрать обязательность авторизации (optional auth)

### Цель

Приложение должно работать **без логина**, auth — не gate, а capability.

### Действия

1. Обновить `router.dart`:

    * маршрут `/counter` сделать **публичным**;
    * удалить редирект `!isAuth → /login`;
    * оставить редирект только:

        * `isAuth && (loc == /login || loc == /signup) → /counter`.
2. Проверить старт приложения без активной сессии.
3. Убедиться, что `/login` и `/signup` остаются доступными вручную.

### Критерий готовности

* Приложение стартует сразу на `/counter` без логина.
* Counter доступен и интерактивен.
* Авторизация не ломает навигацию.

---

## Шаг 2 — Ввести Client Identity (`client_id`)

### Цель

Каждая реплика приложения должна иметь **стабильный локальный идентификатор**.

### Действия

1. Добавить сервис `ClientIdentityService`:

    * генерация UUID при первом запуске;
    * сохранение локально;
    * синхронный доступ.
2. Обеспечить, что `client_id`:

    * не зависит от auth;
    * сохраняется между перезапусками.
3. Подключить `client_id` к логированию операций.

### Критерий готовности

* После перезапуска `client_id` не меняется.
* В логах операций присутствует `client_id`.

---

## Шаг 3 — Перевести Counter на операционную модель

### Цель

Counter перестаёт быть `int` в ViewModel и становится **результатом применения операций**.

### Действия

1. Ввести доменные типы:

    * `CounterOperation`;
    * операция `Increment`.
2. Каждое нажатие кнопки:

    * создаёт операцию;
    * операция имеет `op_id`, `client_id`, `created_at`.
3. Состояние счётчика вычисляется как:

    * `fold(operations)`.

### Критерий готовности

* Counter не мутируется напрямую.
* Повторное применение операций даёт тот же результат.

---

## Шаг 4 — Реализовать Local Op-Log

### Цель

Все изменения фиксируются **сначала локально**, без сервера.

### Действия

1. Реализовать `LocalOpLog`:

    * append operation;
    * хранение списка операций;
    * deduplication по `op_id`.
2. Обеспечить replay op-log для восстановления состояния.
3. (Опционально) добавить локальное persistence.

### Критерий готовности

* Можно очистить state и восстановить его через replay op-log.
* Повторный replay не ломает состояние.

---

## Шаг 5 — Замкнуть Local-first data flow

### Цель

Сформировать стабильный цикл:

```
UI → UseCase → LocalOpLog → Aggregated State → UI
```

### Действия

1. ViewModel:

    * больше не содержит бизнес-логики;
    * только инициирует use case.
2. State формируется вне ViewModel.
3. UI подписывается только на агрегированное состояние.

### Критерий готовности

* UI остаётся «тупым».
* Логика воспроизводима.
* В data-flow отсутствует Supabase.

---

## Шаг 6 — Подключить Auth как событие, а не как условие

### Цель

Auth не ломает local-first поведение.

### Действия

1. Подписаться на `AuthStateListenable`.
2. Реагировать на появление / исчезновение `user_id`:

    * фиксировать факт;
    * **не выполнять sync и realtime** на этом шаге.

### Критерий готовности

* Login / logout не сбрасывает локальные данные.
* Counter продолжает работать после logout.

---

## Шаг 7 — Контрольный прогон сценариев

### Обязательные проверки

1. Без логина:

    * increment работает;
    * reload не теряет данные.
2. Login после локальной работы:

    * данные остаются корректными.
3. Logout:

    * local-only режим продолжается.

### Стоп-критерий

Если любой сценарий не выполняется — **дальше не идти**, исправлять фундамент.

---

## Что категорически запрещено на этом этапе

* Realtime Events
* State Sync
* Supabase таблицы
* Оптимизации
* Масштабирование под mft-2

---

**Результат выполнения всех шагов:**

Рабочий local-first baseline с optional auth, готовый к добавлению Realtime и Sync без пересмотра архитектуры.
