# Execution Playbook — Auth + Realtime + Account-Scoped Sync

**Purpose:** данный документ является **практическим руководством по воспроизведению** архитектуры синхронизации в новом проекте (mft-2).

> **Источник истины:**
> Все архитектурные инварианты, контракты и определения берутся **исключительно** из документа:
> **"Baseline — Auth + Realtime + Account-Scoped State Synchronization (Canonical)"**.
>
> Этот playbook **не вводит новых правил** и **не имеет приоритета** над baseline.

---

## 0. Как пользоваться этим документом

* Baseline читается **один раз полностью** перед началом работ.
* Этот playbook используется:

    * как чеклист реализации,
    * как порядок работ,
    * как контрольная карта для code review.
* Любое расхождение между кодом и baseline считается **дефектом реализации**, а не предметом обсуждения.

---

## 1. Стартовые условия проекта (обязательно)

Перед началом реализации должно быть обеспечено:

* Flutter проект с Riverpod (или эквивалентом DI)
* Supabase SDK подключён
* SharedPreferences (или эквивалент local storage)
* Логирование с возможностью добавлять structured context

Без выполнения этих условий дальнейшие шаги **запрещены**.

---

## 2. Phase 0 — Client Identity (local invariant)

### Цель

Создать фундамент local-first, независимый от auth.

### Шаги

1. Реализовать `ClientIdentityService`:

    * генерация UUID при первом запуске;
    * персистентность между перезапусками;
    * синхронный доступ.
2. Подключить `client_id`:

    * в создание операций;
    * в логирование.

### Проверка

* Перезапуск приложения не меняет `client_id`.

---

## 3. Phase 1 — Account Scope Infrastructure

### Цель

Заложить **account-scoped local state**.

### Шаги

1. Ввести понятие `AccountScope`:

    * `user:<user_id>`
    * `anonymous`
2. Все локальные репозитории обязаны принимать `scope`:

    * Local Op-Log
    * Sync State (cursors)
3. Ключи storage формируются как:

   ```
   <base_key>::<scope>
   ```

### Проверка

* Смена аккаунта не меняет данные другого аккаунта.

---

## 4. Phase 2 — Local Op-Log + Aggregation

### Цель

Состояние формируется **только через операции**.

### Шаги

1. Реализовать доменные операции (append-only).
2. Реализовать Local Op-Log:

    * append
    * deduplication по `op_id`
    * replay
3. Агрегированное состояние считается из op-log.

### Проверка

* Повторный replay даёт тот же результат.

---

## 5. Phase 3 — Auth Integration (без Sync)

### Цель

Auth добавляется как capability, не ломая local-first.

### Шаги

1. Подписаться на `AuthStateChange`.
2. Обеспечить:

    * `null → user_id` НЕ запускает realtime и sync;
    * local-only режим сохраняется.

### Проверка

* Login / logout не меняют локальное состояние.

---

## 6. Phase 4 — Initial Sync (B1)

### Цель

Единожды согласовать состояние клиента и сервера.

### Шаги

1. При появлении `user_id`:

    * создать новый account-scope;
    * инициализировать Local Op-Log;
    * выполнить B1 (PULL → PUSH);
    * инвалидировать read-model;
    * открыть Realtime Gate.

### Проверка

* Повторный запуск не вызывает сетевой активности.

---

## 7. Phase 5 — Realtime + NeedSync

### Цель

Ускорить UX без нарушения консистентности.

### Шаги

1. Подключить realtime **только после B1**.
2. Любое realtime-событие:

    * не применимо → `needSync = true`.
3. NeedSync:

    * debounced;
    * account-scoped;
    * сбрасывается при auth switch.

### Проверка

* Потеря realtime компенсируется sync.

---

## 8. Обязательные интеграционные сценарии

1. A → logout → B → значения изолированы.
2. Две реплики → realtime + sync.
3. Offline → online → reconciliation.
4. Повторный sync → no-op.

Без прохождения всех сценариев система считается **неготовой**.

---

## 9. Code Review Checklist (жёсткий)

* Нет global singleton state без scope.
* Нет сравнения UI-значений.
* Нет local time (везде UTC).
* Нет realtime до B1.
* Нет reuse cursors между аккаунтами.

---

## Финал

Если все фазы выполнены и проверки пройдены —
архитектура считается **корректно перенесённой** в mft-2.

Любые отклонения трактуются как **архитектурные дефекты**,
а не допустимые вариации.

---

## Изменения версии v1.1 (январь 2026)

Данная версия baseline обновлена на основе фактической эксплуатации системы (Web + iOS) и закрытых race-condition.

### Добавленные и уточнённые инварианты

1. **Self-initializing repositories**

   Account-scoped репозитории (Local Op-Log, Sync State и аналогичные) обязаны быть готовы к использованию при первом обращении.

   Запрещено полагаться на внешнюю инициализацию или порядок вызовов провайдеров.

2. **Async safety invariant**

   Ни один асинхронный pipeline не имеет права продолжать выполнение после:

    * смены account scope;
    * logout;
    * dispose инфраструктурного контроллера.

   После каждого `await` обязана выполняться проверка актуальности lifecycle.

3. **Infrastructure controllers lifecycle**

   Контроллеры, управляющие:

    * initial sync (B1),
    * realtime gate,
    * auth / lifecycle реакциями,

   **обязаны быть `keepAlive`** и не могут быть `autoDispose`.

4. **Auth switch = teardown + abort**

   При любом переходе `user_id → null` или `user_id → другой`:

    * предыдущий account scope считается уничтоженным;
    * все pending async pipeline обязаны быть прерваны;
    * побочные эффекты устаревших pipeline запрещены.

Эти правила являются обязательными и распространяются на все последующие проекты (включая mft-2).

**Baseline version:** v1.1
