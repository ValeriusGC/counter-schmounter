# Specification: Snapshot + Op-Log Synchronization Semantics

**Timestamp (Europe/Amsterdam): 2025-12-31 01:02**

## 1. Назначение документа

Данный документ фиксирует **производственную спецификацию синхронизации состояния** для local-first систем на основе **op-log + snapshot**. Спецификация описывает реальные, применяемые на практике сценарии синхронизации между репликами при наличии офлайна, ограниченной истории операций и компактации.

Документ предназначен для использования как:

* архитектурный baseline,
* справочник при реализации Sync слоя,
* источник истины при ревью и отладке.

---

## 2. Исходные определения

* **Replica** — экземпляр приложения на конкретном устройстве.
* **Operation (op)** — атомарное доменное изменение (например, `increment`).
* **Op-log** — упорядоченный журнал операций, хранящийся с ограничением размера.
* **Snapshot** — агрегированное состояние сущности на конкретной ревизии.
* **Revision** — монотонно возрастающий маркер состояния.
* **LocalRevision** — последняя применённая ревизия на реплике.

---

## 3. Базовая модель хранения (сервер)

Сервер **обязан** хранить два представления состояния:

1. **Snapshot**

    * агрегированное состояние сущности;
    * актуальное значение (`counter_value`);
    * `revision`, на которой snapshot валиден.

2. **Op-log (ограниченный)**

    * список операций после snapshot;
    * размер ограничен (например, последние 100 операций).

Сервер **не обязан** хранить полный op-log с начала времени.

---

## 4. Сценарий A — Новая реплика, большая дельта

### Условия

* Replica D1 продвинулась до `revision = 300`.
* Replica D2 только подключилась (`localRevision = 0`).

### Поведение сервера

Сервер возвращает **snapshot** вместо полного op-log:

```json
{
  "snapshot": {
    "state": 300,
    "revision": 300
  },
  "ops": []
}
```

### Поведение клиента (D2)

1. Применить snapshot.
2. Установить `localRevision = 300`.
3. Не проигрывать исторические операции.

### Инвариант

Новая реплика **не обязана** получать и применять полный журнал операций.

---

## 5. Сценарий B — Ограниченная история (compaction)

### Условия

* Максимальный размер op-log = 100 операций.
* Snapshot валиден на `revision = 220`.
* Op-log содержит операции `[221..320]`.
* Replica D2 имеет `localRevision = 50`.

### Обнаружение разрыва

Сервер определяет:

```
localRevision < snapshot.revision
```

Это означает, что клиент **пропустил часть истории**, и чистый replay невозможен.

### Поведение сервера

Сервер возвращает:

```json
{
  "snapshot": {
    "state": 220,
    "revision": 220
  },
  "ops": [221..320]
}
```

### Поведение клиента (D2)

1. Сбросить локальное состояние.
2. Применить snapshot (`state = 220`).
3. Replay op-log (`+100 → state = 320`).
4. Установить `localRevision = 320`.

---

## 6. Ключевые инварианты синхронизации

1. **Op-log не является единственным источником истины.**
2. **Snapshot обязателен** при любой форме compaction.
3. **Replay ops допускается только если история непрерывна.**
4. При разрыве истории клиент **обязан** принимать snapshot.
5. Повторное применение операций **не должно** менять результат (idempotency).

---

## 7. Практические следствия для реализации

* Нельзя проектировать Sync, опираясь только на операции.
* Snapshot — не оптимизация, а обязательный элемент.
* Ограничение истории без snapshot делает систему некорректной.
* Новый клиент всегда должен иметь путь к O(1) восстановлению состояния.

---

## 8. Область применения

Спецификация применима к:

* local-first приложениям;
* offline-first системам;
* multi-device синхронизации;
* event-sourced доменам с компактацией.

---

## 9. Статус документа

**Status:** Approved baseline

Документ является частью архитектурной документации и должен использоваться как источник истины при проектировании и реализации Sync слоя.
