# Baseline: Auth + Realtime Events + State Synchronization (Flutter + Supabase)

**Timestamp (Europe/Amsterdam): 2025-12-30 00:00**

## 0. Введение (коротко)

Этот документ фиксирует baseline-спецификацию для кросс-девайс работы приложения: **авторизация**, **реалтайм-обмен атомарными событиями** и **синхронизация состояния** между копиями. Мы оттачиваем протокол и архитектурные границы на простом стенде (counter), чтобы затем переносить решение в более сложные продукты (например, mft-2) без изменения принципов.

---

## 1. Цели и нецели

### 1.1 Цели

1. **Единый production-паттерн** для Flutter (mobile + web) с Supabase:

    * корректная сессия и redirects,
    * гарантированное восстановление после reload на web,
    * единая модель Identity.
2. **Два независимых механизма доставки данных**:

    * *Realtime events* (малые атомарные сигналы “произошло”),
    * *State sync* (восстановление/догон состояния).
3. **Предсказуемость и дебажность**:

    * минимизация race conditions,
    * трассировка событий,
    * воспроизводимость сценариев рассинхрона.

### 1.2 Нецели

1. Не прорабатываем UI/UX (UI остаётся “тупым”).
2. Не делаем “идеальную” CRDT/OT-редактуру (это отдельный класс задач).
3. Не строим кастомный auth — используем Supabase Auth.

---

## 2. Термины и определения

* **Identity** — стабильный идентификатор пользователя (`user_id`) и валидная session (access/refresh).
* **Replica** — экземпляр приложения на конкретном устройстве/вкладке.
* **Event (Realtime event)** — атомарное действие малого объёма (например, клик, “прибавить 1”).
* **State (состояние)** — совокупность данных домена на момент времени (например, текущее значение счётчика + история операций).
* **Sync** — процесс приведения локального состояния реплики к консистентному состоянию (pull/merge/apply).
* **Version** — монотонно растущий маркер состояния (например, `revision`, `updated_at`, `seq`).
* **Idempotency** — свойство операции, позволяющее безопасно применить её повторно.

---

## 3. Принципиальная архитектура (слои)

### 3.1 Layer A — Auth / Identity (обязательный фундамент)

**Цель:** обеспечить единый источник истины “кто пользователь” и “есть ли активная сессия”.

**Правила:**

1. Истина об авторизации: `supabase.auth.currentSession != null`.
2. Никаких `/loading` маршрутов и флагов `isReady` для восстановления session.
3. Router refresh — через `ChangeNotifier` на `onAuthStateChange`.

**Выход слоя:**

* `userId` (если авторизован),
* сигнал изменения auth-состояния.

### 3.2 Layer B — Realtime Events (операционные сигналы)

**Цель:** доставлять атомарные события “произошло сейчас” между репликами.

**Свойства:**

* payload минимальный,
* допускаются потери (at-most-once) *или* компенсируются через Sync,
* события не являются “истиной состояния”, а лишь ускоряют UX.

### 3.3 Layer C — State Synchronization (корректность состояния)

**Цель:** гарантировать восстановление и догон данных после офлайна/долгого отсутствия.

**Свойства:**

* опирается на versioning,
* поддерживает pull на старте/после reconnect,
* обеспечивает идемпотентное применение.

---

## 3.4 Optional Auth / Local-first Mode

### 3.4.1 Принцип

Auth/Identity слоя A **опционален**: приложение должно сохранять базовую ценность в режиме *local-only* (без `user_id`). Авторизация рассматривается как включаемая capability, открывающая server-side функции (Sync/Realtime), но не как условие входа в основной функционал.

### 3.4.2 Идентичности

В baseline фиксируются два уровня идентичности:

1. **Client Identity (`client_id`)** — локальный UUID реплики (устройства/вкладки), существует всегда и используется для трассировки и дедупликации операций.
2. **User Identity (`user_id`)** — появляется только при auth и используется для server-side функций.

### 3.4.3 Поведение без авторизации (local-only)

1. Пользователь **имеет доступ к главному экрану** и локальному функционалу без регистрации.
2. Realtime events и State Sync **отключены** (не инициализируются, не подписываются), так как отсутствует `user_id`.
3. Локальные изменения фиксируются как операции (op-log) и применяются к локальному состоянию.

### 3.4.4 Переход в авторизованный режим (progressive auth)

При появлении `user_id` (login/signup) система обязана корректно включить server-side возможности:

1. Выполнить первичный Sync (раздел 7) для целевых сущностей.
2. Экспортировать локально накопленные операции (op-log) на сервер **идемпотентно**.
3. Разрешить возможные расхождения по правилам раздела 8 (для counter конфликтов нет).

### 3.4.5 Выход из системы

При logout:

1. Приложение возвращается в local-only режим.
2. UI остаётся доступным; серверные функции выключаются.
3. Локальные операции продолжают записываться в локальный op-log.

---

## 4. Инварианты и требования (обязательные)

### 4.1 Инварианты

1. **Состояние должно быть восстанавливаемым** только через Sync (в пределе). Realtime не обязан доставлять все события.
2. **Каждое доменное изменение должно быть фиксируемым как операция** (минимум для стенда: `increment`).
3. **Любая операция должна быть идемпотентной** на стороне хранилища/применения.

### 4.2 Требования к консистентности

* Для baseline: *eventual consistency* между репликами.
* Разрешение конфликтов — по формальным правилам (см. раздел 7).

---

## 5. Data Model (baseline, без привязки к UI)

### 5.1 Модель “операции” (op-log)

Операции — минимальная единица синхронизации.

Обязательные поля (концептуально):

* `op_id` — UUID,
* `user_id` — владелец,
* `entity_id` — идентификатор сущности (для counter это один `counter_id`),
* `type` — тип операции (например, `increment`),
* `payload` — параметры,
* `created_at` — время на сервере (или клиенте + нормализация),
* `client_id` — идентификатор реплики,
* `seq` или `revision` — монотонный маркер (серверный предпочтительнее).

### 5.2 Модель “состояния” (snapshot)

Опционально для ускорения: хранение агрегированного состояния.

Поля:

* `entity_id`,
* `state` (агрегат),
* `revision`.

---

## 6. Протокол Realtime Events

### 6.1 Назначение

Realtime используется для **ускорения видимости действий** на других репликах, но не заменяет Sync.

### 6.2 Каналы

* Канал определяется как минимум `user_id` и/или `entity_id`.

### 6.3 Формат realtime-сообщения

Минимум:

* `op_id`,
* `entity_id`,
* `type`,
* `payload`,
* `client_id`,
* `sent_at`.

### 6.4 Правила обработки

1. Получатель **пытается применить** операцию локально, если возможно.
2. Если операция неизвестна/неприменима — **ставит флаг needSync** для `entity_id`.
3. Realtime никогда не считается источником истины. Истина — в хранилище + Sync.

---

## 7. Протокол Synchronization

### 7.1 Когда запускается Sync

1. При старте приложения после успешного auth.
2. При восстановлении сети/подключения.
3. По сигналу `needSync` после realtime.
4. По таймеру (опционально), если требуется.

### 7.2 Базовый алгоритм (pull-based)

Для каждой сущности `entity_id`:

1. Клиент знает `localRevision`.
2. Клиент запрашивает на сервер: “дай все операции после `localRevision`” *или* актуальный snapshot.
3. Клиент применяет операции идемпотентно.
4. Клиент обновляет `localRevision`.

### 7.3 Идемпотентность

* Повторное получение одной и той же операции не должно менять итог.
* На клиенте хранить `applied_op_ids` (для стенда можно in-memory; для прод — локальное хранилище).

---

## 8. Конфликты и разрешение

### 8.1 Baseline правило

Для counter конфликтов как класса нет (операция `increment` коммутативна). Это делает стенд идеальным.

### 8.2 Общий случай (для mft-2)

Документ фиксирует только требования:

1. Должно быть определено правило разрешения конфликтов на уровне домена.
2. Должна существовать стратегия “last-write-wins” *или* доменное слияние.
3. Вариант выбирается на уровне сущности, а не глобально.

---

## 9. Требования к реализации во Flutter (baseline)

### 9.1 Router/Auth

* Истина: `currentSession`.
* `refreshListenable` через `ChangeNotifier`.

### 9.2 Клиентские компоненты (минимальный набор)

1. `AuthIdentityService` — выдаёт `userId`, следит за session.
2. `RealtimeEventsService` — подписка/публикация событий.
3. `SyncService` — pull/apply, управление ревизиями.
4. `LocalOpStore` — хранение applied ops / локальная ревизия.

### 9.3 Наблюдаемость (обязательно)

* Логи с корреляционными идентификаторами: `client_id`, `op_id`, `entity_id`.
* Режим диагностики для стенда: принудительный рассинхрон.

---

## 10. План валидации на стенде (Counter)

### 10.1 Сценарии

1. Две вкладки, один пользователь:

    * increment в A → realtime в B.
2. Потеря realtime:

    * отключить канал/не слушать в B,
    * increment в A,
    * B делает Sync → догоняет.
3. Долгий офлайн:

    * закрыть B,
    * на A нащёлкать операции,
    * открыть B → Sync на старте.
4. Idempotency:

    * принудительно повторить получение операций,
    * состояние не меняется сверх ожидаемого.

### 10.2 Критерии готовности

* Нет вечных loading-состояний.
* Realtime ускоряет, Sync исправляет.
* Все сценарии воспроизводимы и логируемы.

---

## 11. Переиспользование в mft-2

**Правило переноса:**

* Мы не меняем слои и протоколы (Auth / Realtime / Sync).
* Мы меняем только:

    * модель операций,
    * модель сущностей,
    * правила конфликтов.

---

## 12. Открытые вопросы (фиксируем, но не решаем без необходимости)

1. Выбор server-side versioning: `revision` vs `created_at` vs `seq`.
2. Snapshot-стратегия: хранить ли агрегаты.
3. Политика ретеншена op-log.
4. Гарантии realtime (at-most-once vs at-least-once) и стоимость подтверждений.
